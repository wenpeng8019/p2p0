/* BEGIN_HEADER */
#include "pk_internal.h"
#include "mbedtls/pem.h"
#include "crypto_oid.h"
#include "mbedtls/base64.h"
#include "psa/crypto_sizes.h"
#include "test/test_keys.h"

typedef enum {
    TEST_PEM,
    TEST_DER
} pkwrite_file_format_t;

typedef enum {
    TEST_WRAP_PSA,
    TEST_COPY_FROM_PSA,
    TEST_COPY_PUBLIC_FROM_PSA,
} pkwrite_pk_derivation_method_t;

typedef enum {
    TEST_PUBLIC_KEY,
    TEST_PRIVATE_KEY,
} pkwrite_key_type_t;

/* Helper function for removing "\r" chars from a buffer. */
static void fix_new_lines(unsigned char *in_str, size_t *len)
{
    size_t chars_left;
    unsigned int i;

    for (i = 0; (i < *len) && (*len > 0); i++) {
        if (in_str[i] == '\r') {
            if (i < (*len - 1)) {
                chars_left = *len - i - 1;
                memmove(&in_str[i], &in_str[i+1], chars_left);
            } else {
                in_str[i] = '\0';
            }
            *len = *len - 1;
        }
    }
}

static int pk_write_any_key(mbedtls_pk_context *pk, unsigned char **p,
                            size_t *buf_len, int is_public_key, int is_der)
{
    int ret = 0;

    if (is_der) {
        if (is_public_key) {
            ret = mbedtls_pk_write_pubkey_der(pk, *p, *buf_len);
        } else {
            ret = mbedtls_pk_write_key_der(pk, *p, *buf_len);
        }
        if (ret <= 0) {
            return ret;
        }

        *p = *p + *buf_len - ret;
        *buf_len = ret;
    } else {
#if defined(MBEDTLS_PEM_WRITE_C)
        if (is_public_key) {
            ret = mbedtls_pk_write_pubkey_pem(pk, *p, *buf_len);
        } else {
            ret = mbedtls_pk_write_key_pem(pk, *p, *buf_len);
        }
        if (ret != 0) {
            return ret;
        }

        *buf_len = strlen((char *) *p) + 1; /* +1 takes the string terminator into account */
#else
        return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
#endif
    }

    return 0;
}

static void pk_write_check_common(char *key_file, int is_public_key, int is_der)
{
    mbedtls_pk_context key;
    mbedtls_pk_init(&key);
    unsigned char *buf = NULL;
    unsigned char *check_buf = NULL;
    unsigned char *start_buf;
    size_t buf_len, check_buf_len;
    int expected_result;
    mbedtls_svc_key_id_t opaque_id = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;

    USE_PSA_INIT();

    /* Note: if mbedtls_pk_load_file() successfully reads the file, then
       it also allocates check_buf, which should be freed on exit */
    TEST_EQUAL(mbedtls_pk_load_file(key_file, &check_buf, &check_buf_len), 0);
    TEST_ASSERT(check_buf_len > 0);

    /* Windows' line ending is different from the Linux's one ("\r\n" vs "\n").
     * Git treats PEM files as text, so when on Windows, it replaces new lines
     * with "\r\n" on checkout.
     * Unfortunately mbedtls_pk_load_file() loads files in binary format,
     * while mbedtls_pk_write_pubkey_pem() goes through the I/O layer which
     * uses "\n" for newlines in both Windows and Linux.
     * Here we remove the extra "\r" so that "buf" and "check_buf" can be
     * easily compared later. */
    if (!is_der) {
        fix_new_lines(check_buf, &check_buf_len);
    }
    TEST_ASSERT(check_buf_len > 0);

    TEST_CALLOC(buf, check_buf_len);

    if (is_public_key) {
        TEST_EQUAL(mbedtls_pk_parse_public_keyfile(&key, key_file), 0);
    } else {
        TEST_EQUAL(mbedtls_pk_parse_keyfile(&key, key_file, NULL), 0);
    }

    start_buf = buf;
    buf_len = check_buf_len;
    if (is_der) {
        expected_result = MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
    } else {
        expected_result = MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL;
    }
    /* Intentionally pass a wrong size for the provided output buffer and check
     * that the writing functions fails as expected. */
    for (size_t i = 1; i < buf_len; i++) {
        TEST_EQUAL(pk_write_any_key(&key, &start_buf, &i, is_public_key,
                                    is_der), expected_result);
    }
    TEST_EQUAL(pk_write_any_key(&key, &start_buf, &buf_len, is_public_key,
                                is_der), 0);

    TEST_MEMORY_COMPARE(start_buf, buf_len, check_buf, check_buf_len);

    /* Verify that pk_write works also for opaque private keys */
    if (!is_public_key) {
        memset(buf, 0, check_buf_len);
        /* Turn the key PK context into an opaque one.
         * Note: set some practical usage for the key to make get_psa_attributes() happy. */
        TEST_EQUAL(mbedtls_pk_get_psa_attributes(&key, PSA_KEY_USAGE_SIGN_MESSAGE, &key_attr), 0);
        TEST_EQUAL(mbedtls_pk_import_into_psa(&key, &key_attr, &opaque_id), 0);
        mbedtls_pk_free(&key);
        mbedtls_pk_init(&key);
        TEST_EQUAL(mbedtls_pk_wrap_psa(&key, opaque_id), 0);
        start_buf = buf;
        buf_len = check_buf_len;
        /* Intentionally pass a wrong size for the provided output buffer and check
         * that the writing functions fails as expected. */
        for (size_t i = 1; i < buf_len; i++) {
            TEST_EQUAL(pk_write_any_key(&key, &start_buf, &i, is_public_key,
                                        is_der), expected_result);
        }
        TEST_EQUAL(pk_write_any_key(&key, &start_buf, &buf_len, is_public_key,
                                    is_der), 0);

        TEST_MEMORY_COMPARE(start_buf, buf_len, check_buf, check_buf_len);
    }

exit:
    psa_destroy_key(opaque_id);
    mbedtls_free(buf);
    mbedtls_free(check_buf);
    mbedtls_pk_free(&key);
    USE_PSA_DONE();
}

static void test_pk_write_pubkey_psa(mbedtls_pk_context *pk)
{
    uint8_t buf[PSA_EXPORT_PUBLIC_KEY_MAX_SIZE + 1];
    size_t buf_len, cur_size, safe_export_size;
    int expected_ret;
    int is_ec = PSA_KEY_TYPE_IS_ECC(mbedtls_pk_get_key_type(pk));

    /* Compute the minimum buffer size that allows the export to be successful for
     * the given key. */
    if (is_ec) {
        safe_export_size = PSA_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE(mbedtls_pk_get_bitlen(pk));
    } else {
        safe_export_size = PSA_KEY_EXPORT_RSA_PUBLIC_KEY_MAX_SIZE(mbedtls_pk_get_bitlen(pk));
    }

    for (cur_size = 0; cur_size < sizeof(buf); cur_size++) {
        mbedtls_test_set_step(cur_size);
        if (cur_size >= safe_export_size) {
            /* If the buffer size is at least the safe length, then export must succeed. */
            expected_ret = 0;
        } else if ((cur_size >= pk->pub_raw_len) && (pk->pub_raw_len > 0)) {
            /* If it's less than the safe length it might still succeed, but it depends
             * on the real length of the data stored in the PK context. In this case
             * "pk->pub_raw_len" must be set, of course. */
            expected_ret = 0;
        } else {
            expected_ret = MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
        }

        TEST_EQUAL(mbedtls_pk_write_pubkey_psa(pk, buf, cur_size, &buf_len), expected_ret);
        if (expected_ret == 0) {
            TEST_EQUAL(buf_len, pk->pub_raw_len);
        }
    }

exit:; /* The ";" is intentional: we need the "exit" label, but we don't have any action to
        * to do, so the compiler would complain for that. */
}

static mbedtls_svc_key_id_t make_psa_key_from_predefined(psa_key_type_t key_type,
                                                         psa_key_bits_t key_bits)
{
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_attributes_t attr = PSA_KEY_ATTRIBUTES_INIT;
    const uint8_t *priv_key = NULL;
    size_t priv_key_len = 0;

    if (key_type == PSA_KEY_TYPE_RSA_KEY_PAIR) {
        if (key_bits == 1024) {
            priv_key = test_rsa_1024_priv;
            priv_key_len = sizeof(test_rsa_1024_priv);
        } else if (key_bits == 4096) {
            priv_key = test_rsa_4096_priv;
            priv_key_len = sizeof(test_rsa_4096_priv);
        }
    } else if (key_type == PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1)) {
        if (key_bits == 256) {
            priv_key = test_ec_secp256r1_priv;
            priv_key_len = sizeof(test_ec_secp256r1_priv);
        } else if (key_bits == 521) {
            priv_key = test_ec_secp521r1_priv;
            priv_key_len = sizeof(test_ec_secp521r1_priv);
        }
    } else {
        TEST_FAIL("Unsupported key");
    }

    psa_set_key_usage_flags(&attr, PSA_KEY_USAGE_EXPORT);
    psa_set_key_type(&attr, key_type);
    PSA_ASSERT(psa_import_key(&attr, priv_key, priv_key_len, &key_id));

exit:
    return key_id;
}
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_PK_PARSE_C:MBEDTLS_PK_WRITE_C:MBEDTLS_FS_IO
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void pk_write_pubkey_check(char *key_file, int is_der)
{
    pk_write_check_common(key_file, 1, is_der);
    goto exit; /* make the compiler happy */
}
/* END_CASE */

/* BEGIN_CASE */
void pk_write_key_check(char *key_file, int is_der)
{
    pk_write_check_common(key_file, 0, is_der);
    goto exit; /* make the compiler happy */
}
/* END_CASE */

/* BEGIN_CASE */
void pk_write_public_from_private(char *priv_key_file, char *pub_key_file)
{
    mbedtls_pk_context priv_key;
    uint8_t *derived_key_raw = NULL;
    size_t derived_key_len = 0;
    uint8_t *pub_key_raw = NULL;
    size_t pub_key_len = 0;
    mbedtls_svc_key_id_t opaque_key_id = MBEDTLS_SVC_KEY_ID_INIT;
    psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;

    mbedtls_pk_init(&priv_key);
    USE_PSA_INIT();

    TEST_EQUAL(mbedtls_pk_parse_keyfile(&priv_key, priv_key_file, NULL), 0);
#if defined(PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY)
    if (mbedtls_pk_get_type(&priv_key) == MBEDTLS_PK_RSA) {
        TEST_EQUAL(mbedtls_pk_set_pubkey_from_prv(&priv_key), 0);
    }
#endif /* PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY */
    TEST_EQUAL(mbedtls_pk_load_file(pub_key_file, &pub_key_raw,
                                    &pub_key_len), 0);

    derived_key_len = pub_key_len;
    TEST_CALLOC(derived_key_raw, derived_key_len);

    TEST_EQUAL(mbedtls_pk_write_pubkey_der(&priv_key, derived_key_raw,
                                           derived_key_len), pub_key_len);

    TEST_MEMORY_COMPARE(derived_key_raw, derived_key_len,
                        pub_key_raw, pub_key_len);

    mbedtls_platform_zeroize(derived_key_raw, derived_key_len);

    /* Turn the priv_key PK context into an opaque one. */
    TEST_EQUAL(mbedtls_pk_get_psa_attributes(&priv_key, PSA_KEY_USAGE_SIGN_HASH, &key_attr), 0);
    TEST_EQUAL(mbedtls_pk_import_into_psa(&priv_key, &key_attr, &opaque_key_id), 0);
    mbedtls_pk_free(&priv_key);
    mbedtls_pk_init(&priv_key);
    TEST_EQUAL(mbedtls_pk_wrap_psa(&priv_key, opaque_key_id), 0);

    TEST_EQUAL(mbedtls_pk_write_pubkey_der(&priv_key, derived_key_raw,
                                           derived_key_len), pub_key_len);

    TEST_MEMORY_COMPARE(derived_key_raw, derived_key_len,
                        pub_key_raw, pub_key_len);

exit:
    psa_destroy_key(opaque_key_id);
    mbedtls_free(derived_key_raw);
    mbedtls_free(pub_key_raw);
    mbedtls_pk_free(&priv_key);
    USE_PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void pk_write_pubkey_psa_from_file(char *key_file, int is_private)
{
    mbedtls_pk_context pk;

    mbedtls_pk_init(&pk);

    PSA_INIT();

    if (is_private) {
        TEST_EQUAL(mbedtls_pk_parse_keyfile(&pk, key_file, NULL), 0);
    } else {
        TEST_EQUAL(mbedtls_pk_parse_public_keyfile(&pk, key_file), 0);
    }

    /* No need to check for return value here: TEST_EQUAL() macros are used in this function */
    test_pk_write_pubkey_psa(&pk);

exit:
    mbedtls_pk_free(&pk);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void pk_write_pubkey_psa_from_psa(int key_type, int key_bits, int pk_gen_method)
{
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    mbedtls_pk_context pk;

    mbedtls_pk_init(&pk);

    PSA_INIT();

    key_id = make_psa_key_from_predefined(key_type, key_bits);

    switch (pk_gen_method) {
        case TEST_WRAP_PSA:
            TEST_EQUAL(mbedtls_pk_wrap_psa(&pk, key_id), 0);
            break;
        case TEST_COPY_FROM_PSA:
            TEST_EQUAL(mbedtls_pk_copy_from_psa(key_id, &pk), 0);
            break;
        case TEST_COPY_PUBLIC_FROM_PSA:
            TEST_EQUAL(mbedtls_pk_copy_public_from_psa(key_id, &pk), 0);
            break;
        default:
            TEST_FAIL("Unknown method");
    }

    /* No need to check for return value here: TEST_EQUAL() macros are used in this function */
    test_pk_write_pubkey_psa(&pk);

exit:
    mbedtls_pk_free(&pk);
    psa_destroy_key(key_id);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void pk_write_pubkey_psa_unpopulated(void)
{
    unsigned char buf[PSA_EXPORT_PUBLIC_KEY_MAX_SIZE];
    size_t buf_len;
    mbedtls_pk_context pk;

    mbedtls_pk_init(&pk);
    PSA_INIT();

    TEST_EQUAL(MBEDTLS_ERR_PK_BAD_INPUT_DATA,
               mbedtls_pk_write_pubkey_psa(&pk, buf, sizeof(buf), &buf_len));

exit:
    mbedtls_pk_free(&pk);
    PSA_DONE();
}
/* END_CASE */
